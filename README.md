# A Browser-based MIPS Assembler and Simulator

## Project Summary:
We are developing a set of browser-based tools designed to illustrate various
aspects of Computer Architecture and Assemble Language Programing. The primary 
audience of these tools are freshman computer science students, who are 
learning the basics of an ISA (instruction set architecture). Whenever possible, the
material is presented in an architecture neutral way--but focused on a RISC-based
architecture.

Central to these tools is an assembler and simulator, in which we have chosen the
MIPS ISA as our initial implementation. These two tools share a common file that
represents a valid MIPS program along with a rich set of metadata. The assembler creates
a .json file that contains the following information:

   1. the original source files, coupled with syntax analysis
   1. a symbol table containing information for all labels, macros, and definitions
   1. an overlay data structure that provides aggregate information for a set of bytes
   1. a core file, containing the byte-level encoding for both the .text and .data segments

The CLI-based simulator can consume a subset of the core file to execute the MIPS program 
to start to finish. Whereas the GUI-based simulator can also consume the overlay data 
structure to provide additional information to the programmer during the debugging process.

![Assembler-Simulator Architecture](image.png "Assembler-Simulator Architecture").

It is envisioned that other tools or gadgets can be developed using the other information 
generated by the assembler. For example:
   1. a memory layout tool can be develop to show the difference when data 
      - aligned verses not aligned
      - big endian verses little endian ordering
   1. a watch-window can be added to the GUI-based simulator using the symbol table

## Project Goals:
   * to provide a set of in-browser tools as a learn / teaching aid for CS freshman
   * to provide a 100% in-browser assembler for MIPS assembly language
   * ~~to provide a complete and efficient assembler~~
   * to provide a 100% in-browser simulator for MIPS assembly language
   * ~~to provide a complete and efficient simulator~~
   * to provide a 100% in-browser emulator for the MIPS ISA
   * to provide a set of tools to illustrate and to reinforce the following topics:
     * formats: instructions, binary numbers (signed & unsigned), chars, floats
     * number representation: binary, octal, decimal, and hexadecimal 
     * memory organization: segments, endianness, activation records (frame), etc
   * to provide a .json file for an valid and assembled MIPS program, which can be used to develop other independent learning tools


## Repository Summary
This repository contains primarily documentation and examples of the .json file format. The MIPS assembler and MIPS simulator are contained within independent repositories that can be added as modules to this repository.

## Directory
   1. [JSON File Format Definition](/json-definition): (.json)
   1. [Data Dictionary of JSON attributes](/data-dictionary)
   1. [Assembler Output Example](/sample): (sample.s --> sample.json)


## Acknowledgements and Attributions:

[SPIM](http://spimsimulator.sourceforge.net) and [MARS](https://courses.missouristate.edu/KenVollmar/MARS/) are two simulators for the MIPS assembly language. I have used both of these tools within my freshman Computer Architecture class to great success. 

The design of our system has been greatly influenced by these to simulators, each having a different set of features.  Our goal is to build new system, which is 100% browser-based, that incorporates the best features of these two systems.



For a full description of the JSON file format see.. JSON.BNF.md

```json
{ "program": "<general description>",
    "entry": "main",
    "source_files": [], // an array of text representing the original source program
    "labels": {   // the symbol table of all labels
          "defines": [], "macros": [], "data" : [], "text" : [] 
          }, // See symbol_table.md for more information


    "overlays": [ // an array of segments defined by the user's program, with each segment providing an array of declarations or instructions
                  { "segment": ".text",   //
                    "alignment": "off",   //  { "on", "off" }     : Indicates if memory alignment was performed
                    "wordsize": 4,        //  --> Is this necessary?
                    "endianness": "big",  //  { "big", "little" } : Indicates the endianness used for byte ordering
                    "address": null,      //  The starting address of this associated segment
                    "size": null,         //  The number of bytes associated with the segment
                    "comment": null,      //  The comment that appeared on the ".text" directive line
                    "statements": []      //  The list of statements defined within the segment
                  },
    ],
 
   // DATA: 
   //    - source: defines the declarations as defined textual, with the given structure
   //    - memory: defines the raw values in memory, without any labels
   //    - overlay: defines the associate labels, alignment, structure, etc.

   // TEXT
   //    - source: defines the instructions as defined textual
   //    - memory: defines the encode instructions, without any any labels
   //    - overlay: defines the associate labels, structure (associated structure), etc.
   //               moreover the overlay does not contain non native instructions


    "core": { 
        "memory": [   // an array of named segments within main memory
            { "segment": ".data", "start": "0x01001000", "end": "0x01001000",
              "values": [ 
                {"address": "0xFFFF", "value": "0xFFFF" },
                {"address": "0xFFFF", "value": "0xFFFF" },
                {"address": "0xFFFF", "value": "0xFFFF" } 
                // any memory address not enumerated implies that value is undetermined
             ]
            },
            { "segment": ".text", "start": "0x01001000", "end": "0x01001000", 
              "values": [
                {"address": "0xFFFF", "value": "0xFFFF" },
                {"address": "0xFFFF", "value": "0xFFFF" },
                {"address": "0xFFFF", "value": "0xFFFF" },
                {"address": "0xFFFF", "value": "0xFFFF" }
                // any memory address not enumerated implies error
             ]
            }
            // additional memory segments can be provided
        ],
        "CPU": [ ], // a register array with current values
        "CPO": [ ], // a register array with current values
        "FPU": [ ] // a register array with current values
    }
}


